{-# language OverloadedStrings, TupleSections #-}
module Dampf.Test where

import Dampf.Monitor
import Dampf.Docker.Free
import Dampf.Docker.Args.Class

import qualified Data.Text as T
import qualified Data.ByteString.Lazy.Char8 as BL

runTest :: (MonadIO m, MonadThrow m) => Tests -> DampfT m ()
runTest = _

  runUnits :: (MonadIO m, MonadThrow m) => (Text, TestSpec) -> DampfT m ()
  runUnits = _

  go :: (MonadIO m, MonadThrow m) => TestUnit -> DampfT m ()
  go (TestRun img cmd) = _

  go (TestGet uri mb_pattern) = do
    netName <- readDockerProcess $
        "run"
      # "--rm"
      # img
      # "uuidgen"

    runDockerProcess $
        "network"
      # "create"
      # netName
  
    runDockerProcess $ 
        "run"
      # "-it"
      # "--rm"
      # namedBstrArg netName

    runWith 
      

    res <- liftIO (get . unpack $ uri)

    let res_code = view (responseStatus . statusCode) res

    report (show uri)

    if res_code /= 200 
      then report ("failed. response code: " <> show res_code) *> liftIO exitFailure
      else case mb_pattern of
        Nothing -> report "success"
        Just pattern -> if view responseBody res =~ unpack pattern
          then report "success"
          else report ("pattern " <> show pattern <> " didn't match") *> liftIO exitFailure
